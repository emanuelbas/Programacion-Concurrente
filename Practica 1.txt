1. 
Para los primeros ejercicios hay que tener en cuenta que las instrucciones no son atómicas, por ejemplo
x:= (x*3)+(x*2)+1 involucra diferentes acciones separadas, x*3, x*2, +1, x:=.. 
El hecho de que el programa sea concurrente involucra que un proceso puede intervenir entre las instrucciones de otro y ocacionar que tenga un resultado diferente según el orden en que se mezclan, es decir su historial

A. 
Se ejecuta todo P1, y x toma el valor 10
Se ejecuta todo P2, y x toma el valor 11
Se ejecuta todo P3, y x toma el valor 56

B.
Se ejecuta del P3 (x*3), (0*3) es 0, se interrumpe el proceso
Se ejecuta todo P1, X toma el valor 10
Se continua la ejecución de P3, x:= 0 + (x*2) +1, X toma el valor 21
Se ejecuta todo P2, X toma el valor 22

C.
Se ejecuta del P3 (x*3), (0*3) es 0, se interrumpe el proceso
Se ejecuta todo P1, X toma el valor 10
Se ejecuta todo P2, X toma el valor 11
Se continua la ejecución de P3, x:= 0 + (x*2) +1, X toma el valor 23

D.
Si, hay almenos un proceso que puede tomar una accion que invalide las suposiciones de otro proceso.
Por ejemplo podria pasar que en el P1 se cruce el If(X=0), se le quite el procesador para darselo al P3 que le da el valor 1 a X. A continuación se regresaría al P1 teniendo X en 1, cuando se supone que solo se podia ingresar cuando X era 0.

2. 
Voy a crear una variable global de tipo arreglo, un contador y varios procesos concurrentes

arreglo = Array of integer [1..M]
int total = 0
const N

Una primera aproximación podría pensarse como M procesos que revisan cada celda del vector en forma concurrente, pero esto lleva a un problema, tener demasiados procesos concurrentes ocaciona que no todos puedan acceder al recurso, por lo que es mejor seccionar el vector en varias partes.. la catidad de secciones en que se separa el vector dependerá del problema, aca voy a dejar un numero cualquiera. Ademas si la cantidad de procesos es muy grande tambien sera util no actualizar la variable global a menos de que sea necesario.

Process contador [i:1..4] //Esta notación indica que habra 4 procesos concurrentes y la i puede ser usada
int local = 0
int limiteInferior, limiteSuperior //Asignarles el valor que tendrian segun el proceso
for j=limiteInferior to limiteSuperior
	if arreglo[j] == N then local++
if (local > 0) then <total = total + local>

3.
Nota que el await solo permitira que el filosofo coma cuando se cumpla que sus 2 tenedores estan libres, ademas de forma atomica se deshabilitaran ambos tenedores para que otros filosofos no puedan usarlo, las boquitas indican que lo que va adentro se ejecutara de forma atomica, es decir todo junto sin permitir que se colen otros procesos
Se evita el deadlock dado que se garantiza que una vez dentro del sector critico eventualmente se va a salir liberando los tenedores, seria un problema si no incluiria ambos tenedores en la atomicidad porque entonces si podria pasar que varios filosofos retengan uno de los tenedores pero no puedan empezar porque otro filosofo tenga el que requieren
La espera innecesaria se produciría si liberaria ambos tenedores de forma atómica, ya que puedo liberarlos por separado para que otro filósfo vaya usando el primero en liberarse, sin tener que esperar a que el otro (que no lo necesita) también se libere

t = Array of boolean [1..5] //hay 5 cuchillos para 6 filosofos, si estan en true estan libres
//Inicializar todos los tenedores en true
Process filosofo [i:1..6]
int posI = i //Posicion del tenedor izquierdo para este filosofo
int posD = i mod 6 + 1 //En caso de ser 6 su pos derecha dara 1
while true
	<wait ((t[posI] == true) AND (t[posD] == true)); t[posI] = false; t[posD] = false>
	//Filosofo comiendo, a esto se le llama sector critico
	//Para salir del sector critico debo librerar los tenedores
	t[posD] = false; t[postI] = false

