1.
sem detector:= 1
Process persona [i:1..N]{
P(detector)
//SC
V(detector)
}

Para que pasen mas personas por detector en simultaneo aumento el numero del semaforo.

2.
cola Q[N]
sem recurso = 5; Q_mutex = 1
Process proceso[i:1..N]{
	P(recurso)
	P(Q_mutex)
	RecursoLocal = Q.POP()
	V(Q_mutex)
	//SC donde se utiliza el recurso
	//Devuelvo el recurso a la pila
	P(Q_mutex)
	Q.PUSH(RecursoLocal)
	V(Q_mutex)
	V(recurso)	
}

3. Si se pasa el semaforo general antes que el especifico del tipo de proceso, en un caso extremo podria darse que aun el tipo de proceso no pueda pasar, mientras que el otro si deberia pero quedo trabado porque el tipo que no puede pasar consumio el semaforo general.
Entonces la solucion seria invertir el orden de los semaforos para que primero se haga check sobre el tipo de proceso y luego espere un lugar
Sobre liberar el recurso se recomienda liberarlos en el mismo orden en que fueron tomados pero para este caso no afecta ya que son consecutivos

4.
type
tarea = record (int alumno, string tarea);
var
boolean resultados[1:40] = ([40], false) 
sem ready[1:40] = ([40], 1)
sem Q_mutex = 1
sem hayTareas = 0
queue of tarea tareas[1:40]


Process alumno [a:1..40]{
//Espera por que la profesora le de la tarea
	P(ready[a])
	while (resultados[a] = false){
//Realiza la tarea y la encola para correccion
		//HacerTarea
		P(Q_mutex)
		Q_tareas.PUSH(new tarea(a,tarea))
		V(Q_mutex)
		V(hayTareas) //Aviso que hay al menos esta tarea en la cola
//Espera los resultados, si termino puede irse 
		P(ready[a]) //Espero resultados
	}
}

Process maestra{
	tarea tareaActual
//reparte las tareas
	for i=1; i<40;i++ {
		V(ready[i])
	}
//revisa las tareas hasta que las 40 esten terminadas
	int terminadas = 0
	while (terminadas < 40) {
		P(hayTareas)
		P(Q_mutex)
		Q_tareas.POP(tareaActual)
		if tareaActual.esCorrecta() 
			terminadas ++
		else 
			tareaActual.comentarErrores()
		resultados[tareaActual.alumno] = true
	}
}