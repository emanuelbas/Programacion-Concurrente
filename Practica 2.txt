1.
sem detector:= 1
Process persona [i:1..N]{
P(detector)
//SC
V(detector)
}

Para que pasen mas personas por detector en simultaneo aumento el numero del semaforo.

2.
cola Q[N]
sem recurso = 5; Q_mutex = 1
Process proceso[i:1..N]{
	P(recurso)
	P(Q_mutex)
	RecursoLocal = Q.POP()
	V(Q_mutex)
	//SC donde se utiliza el recurso
	//Devuelvo el recurso a la pila
	P(Q_mutex)
	Q.PUSH(RecursoLocal)
	V(Q_mutex)
	V(recurso)	
}

3. Si se pasa el semaforo general antes que el especifico del tipo de proceso, en un caso extremo podria darse que aun el tipo de proceso no pueda pasar, mientras que el otro si deberia pero quedo trabado porque el tipo que no puede pasar consumio el semaforo general.
Entonces la solucion seria invertir el orden de los semaforos para que primero se haga check sobre el tipo de proceso y luego espere un lugar
Sobre liberar el recurso se recomienda liberarlos en el mismo orden en que fueron tomados pero para este caso no afecta ya que son consecutivos

4.
type
tarea = record (int alumno, string tarea);
var
boolean resultados[1:40] = ([40], false) 
sem ready[1:40] = ([40], 1)
sem Q_mutex = 1
sem hayTareas = 0
queue of tarea tareas[1:40]


Process alumno [a:1..40]{
//Espera por que la profesora le de la tarea
	P(ready[a])
	while (resultados[a] = false){
//Realiza la tarea y la encola para correccion
		//HacerTarea
		P(Q_mutex)
		Q_tareas.PUSH(new tarea(a,tarea))
		V(Q_mutex)
		V(hayTareas) //Aviso que hay al menos esta tarea en la cola
//Espera los resultados, si termino puede irse 
		P(ready[a]) //Espero resultados
	}
}

Process maestra{
	tarea tareaActual
//reparte las tareas
	for i=1; i<40;i++ {
		V(ready[i])
	}
//revisa las tareas hasta que las 40 esten terminadas
	int terminadas = 0
	while (terminadas < 40) {
		P(hayTareas)
		P(Q_mutex)
		Q_tareas.POP(tareaActual)
		if tareaActual.esCorrecta() 
			terminadas ++
		else 
			tareaActual.comentarErrores()
		resultados[tareaActual.alumno] = true
	}
}

5.
//Primero los 50 elijen la tarea, luego comienzan
sem mutex_contar = 1 
int cont = 0
sem comenzar = 0
sem esperar_elecciones = 0

//Se activa cuando todos los alumnos 
//terminen la tarea
bool finTarea[1:10] = ([10],false) 

//Semaforo que lleva la cantidad de 
//alumnos que desean entregar
sem hay_alumno_entregando = 0

//La maestra recibe la entrega
sem entregar = 0 

//El alumno avisa que los datos fueron enviados
int id_alumno
int id_tarea
sem entregados= 0 

//De cada alumno se guarda el orden en que 
//resolvio su tarea
int orden[1:50]

//Un semaforo permitira pasa cuando los 5 
//alumnos terminen su tarea
int retirarse[1:10] = ([10] 0)

Process alumno[i:1..50]{
	
	int t= elegir()
	P(mutex_contar)
	cont++
	if (cont == 50) {
		V(esperar_elecciones)
	}
	else {
		V(mutex_contar)
	}
	P(comenzar)
	string tarea = resolverTarea()
	V(hay_alumno_entregando)
	P(entregar)
	id_alumno = i
	id_tarea = t
	V(entreagados)
	P(retirarse[t])
	

}

Process maestra{
//La maestra llevara la cuenta de cuantos 
//alumnos van entregando cada tipo de tarea
int contTarea[1:10] = ([10],0) 

//Espera que los alumnos elijan
//El ultimo avisara
P(esperar_elecciones)

//Permite comenzar
for i=1,i<50,i++ 
	V(comenzar)


For i=1,i<50,i++ {
	P(hay_alumno_entregando)
	V(entregar)
	P(entregados)
	contTarea[id_tarea]++
	orden[id_alumno] = contTarea[id_tarea]
	if (contTarea[id_tarea] == 5) 
		for (i=1,i<5,i++)
			P(retirarse[id_tarea]
	}
}


5. (Un segundo intento)

sem mutex_eleccion = 1
sem barrera_eleccion = 0
int cont_eleccion = 0

sem mutex_avisar = 1
int global_alumno, global_tarea, global_posicion
sem avisar = 0

sem[1:50] barrera_posicion = ([1:50]0)


Process alumno[a:1..50]

int tarea = elegir(a)
P(mutex_eleccion)
cont_eleccion++
if (cont_eleccion == 50)
	for (i=1,i<50,i++)
		V(barrera_eleccion)
else 
	V(mutex_eleccion)
P(barrera_eleccion)
hacer_tarea()
P(mutex_avisar)
global_alumno = a
global_tarea = tarea
V(avisar)
P(barrera_posicion[a])
write('mi posicion es ',global_posicion)



Process maestra

int tareas_terminadas = 0
int[1:50] posiciones
int[1:10] cont_tareas = ([1:10]0)

//Almacena los alumnos que pertenecen a cada tarea
queue of int[1:10] alumnos_de_tarea 

while (tareas_terminadas < 10)
	P(avisar)
	cont_tareas[global_tarea]++
	posiciones[global_alumno] = cont_tareas[global_tarea]
	alumnos_de_tarea.push(global_alumno)
	if (cont_tareas[global_tarea] == 5)
		tareas_terminadas++
		for i=0,i<5,i++
			a = alumnos_de_tarea[global_tarea].pop()
			global_posicion = posiciones[a]
			V(barrera_posicion[a])
			



6.

sem llegada = 0
sem comenzar = 0
sem mutex_tareas = 1
queue of Tarea tareas
int cont[1:E] = ([1:E] 0)
sem listo = 0

Process empleado[i:1..E]{

V(llegada)
P(comenzar)

P(mutex_tareas)
while not tareas.isEmpty(){
	Tarea tareaActual = tareas.pop()
	V(mutex_tareas)
	tareaActual.realizar()
	cont[i]++
	P(mutex_tareas)
}
V(listo)
}

Process Jefe{
	for (i=1,i<E,i++){
		P(llegada)
	}
	for (i=1,i<E,i++){
		V(comenzar)
	}
	for (i=1,i<E,i++){
		P(listo)
	}
	calcularMax(cont)
	
}

7.
